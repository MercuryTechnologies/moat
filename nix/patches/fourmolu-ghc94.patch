Upstream PR: https://github.com/fourmolu/fourmolu/pull/242

diff --git a/data/examples/declaration/value/function/arrow/proc-lets-four-out.hs b/data/examples/declaration/value/function/arrow/proc-lets-four-out.hs
index 8d587c1..41153fd 100644
--- a/data/examples/declaration/value/function/arrow/proc-lets-four-out.hs
+++ b/data/examples/declaration/value/function/arrow/proc-lets-four-out.hs
@@ -3,10 +3,12 @@
 foo f = proc a -> let b = a in f -< b

 bar f g = proc a ->
-    let h =
+    let
+        h =
             f
                 . g a
         j =
             g
                 . h
-     in id -< (h, j)
+     in
+        id -< (h, j)
diff --git a/data/examples/declaration/value/function/arrow/proc-do-complex-four-out.hs b/data/examples/declaration/value/function/arrow/proc-do-complex-four-out.hs
index 80e0fa9..d332de7 100644
--- a/data/examples/declaration/value/function/arrow/proc-do-complex-four-out.hs
+++ b/data/examples/declaration/value/function/arrow/proc-do-complex-four-out.hs
@@ -31,10 +31,12 @@ foo
                             , w
                             ) -> \u ->
                             -- Procs can have lambdas
-                            let v =
+                            let
+                                v =
                                     u -- Actually never used
                                         ^ 2
-                             in ( returnA
+                             in
+                                ( returnA
                                     -<
                                         -- Just do the calculation
                                         (x + y * z)
diff --git a/data/examples/declaration/value/function/blank-lines-let-four-out.hs b/data/examples/declaration/value/function/blank-lines-let-four-out.hs
index 67767f3..9b698a6 100644
--- a/data/examples/declaration/value/function/blank-lines-let-four-out.hs
+++ b/data/examples/declaration/value/function/blank-lines-let-four-out.hs
@@ -1,6 +1,8 @@
 foo =
-    let x = 10
+    let
+        x = 10

         y = 11
         z = 12
-     in x + y + z
+     in
+        x + y + z
diff --git a/data/examples/other/invalid-haddock-weird-four-out.hs b/data/examples/other/invalid-haddock-weird-four-out.hs
t.hs
index a4d16a2..233f2bb 100644
--- a/data/examples/other/invalid-haddock-weird-four-out.hs
+++ b/data/examples/other/invalid-haddock-weird-four-out.hs
@@ -1,3 +1,5 @@
 {-# LANGUAGE TemplateHaskell #-}

-foo = foo -- \|# ${
+foo = foo
+
+-- \|# ${
diff --git a/data/examples/other/invalid-haddock-weird-out.hs b/data/examples/other/invalid-haddock-weird-out.hs
index a4d16a2..233f2bb 100644
--- a/data/examples/other/invalid-haddock-weird-out.hs
+++ b/data/examples/other/invalid-haddock-weird-out.hs
@@ -1,3 +1,5 @@
 {-# LANGUAGE TemplateHaskell #-}

-foo = foo -- \|# ${
+foo = foo
+
+-- \|# ${
diff --git a/data/examples/other/invalid-haddock-weird.hs b/data/examples/other/invalid-haddock-weird.hs
index 2e6a889..233f2bb 100644
--- a/data/examples/other/invalid-haddock-weird.hs
+++ b/data/examples/other/invalid-haddock-weird.hs
@@ -1,3 +1,5 @@
 {-# LANGUAGE TemplateHaskell #-}

-foo = foo -- |# ${
+foo = foo
+
+-- \|# ${
diff --git a/data/fourmolu/let-style/input.hs b/data/fourmolu/let-style/input.hs
new file mode 100644
index 0000000..8520c79
--- /dev/null
+++ b/data/fourmolu/let-style/input.hs
@@ -0,0 +1,92 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+  in  a + 2
+
+let_single_sig =
+  let a :: Int
+      a = 1
+  in  a + 2
+
+let_multi =
+  let a = 1
+      b = 2
+  in  a + b
+
+let_single_newline =
+  let
+    a = 1
+  in
+    a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let b = 2
+      c = 3
+
+  let d = "hello"
+   in print d
+
+  let d = "hello"
+      e = "world"
+   in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let b = 2
+        c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=2.hs b/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=2.hs
new file mode 100644
index 0000000..9c9021a
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=2.hs
@@ -0,0 +1,92 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+  in  a + 2
+
+let_single_sig =
+  let a :: Int
+      a = 1
+  in  a + 2
+
+let_multi =
+  let a = 1
+      b = 2
+  in  a + b
+
+let_single_newline =
+  let
+    a = 1
+  in
+    a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let b = 2
+      c = 3
+
+  let d = "hello"
+   in print d
+
+  let d = "hello"
+      e = "world"
+   in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let b = 2
+        c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let b = 2
+            c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=4.hs b/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=4.hs
new file mode 100644
index 0000000..03680a0
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetAuto-InLeftAlign-indent=4.hs
@@ -0,0 +1,92 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+    in  a + 2
+
+let_single_sig =
+    let a :: Int
+        a = 1
+    in  a + 2
+
+let_multi =
+    let a = 1
+        b = 2
+    in  a + b
+
+let_single_newline =
+    let
+        a = 1
+    in
+        a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+    in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let d = "hello"
+        e = "world"
+     in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let b = 2
+          c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let b = 2
+                  c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let b = 2
+              c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=2.hs b/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=2.hs
new file mode 100644
index 0000000..5d71700
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=2.hs
@@ -0,0 +1,92 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+   in a + 2
+
+let_single_sig =
+  let a :: Int
+      a = 1
+   in a + 2
+
+let_multi =
+  let a = 1
+      b = 2
+   in a + b
+
+let_single_newline =
+  let
+    a = 1
+   in
+    a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+   in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let b = 2
+      c = 3
+
+  let d = "hello"
+   in print d
+
+  let d = "hello"
+      e = "world"
+   in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let b = 2
+        c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let b = 2
+            c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=4.hs b/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=4.hs
new file mode 100644
index 0000000..2b5d71a
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetAuto-InRightAlign-indent=4.hs
@@ -0,0 +1,92 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+     in a + 2
+
+let_single_sig =
+    let a :: Int
+        a = 1
+     in a + 2
+
+let_multi =
+    let a = 1
+        b = 2
+     in a + b
+
+let_single_newline =
+    let
+        a = 1
+     in
+        a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+     in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let d = "hello"
+        e = "world"
+     in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let b = 2
+          c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let b = 2
+                  c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let b = 2
+              c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=2.hs b/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=2.hs
new file mode 100644
index 0000000..24edb6d
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=2.hs
@@ -0,0 +1,88 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+  in  a + 2
+
+let_single_sig =
+  let a :: Int
+      a = 1
+  in  a + 2
+
+let_multi =
+  let a = 1
+      b = 2
+  in  a + b
+
+let_single_newline =
+  let a = 1
+  in  a + 2
+
+let_multi_newline =
+  let a = 1
+      b = 2
+  in  a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let b = 2
+      c = 3
+
+  let d = "hello"
+   in print d
+
+  let d = "hello"
+      e = "world"
+   in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let b = 2
+        c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let b = 2
+            c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=4.hs b/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=4.hs
new file mode 100644
index 0000000..942dd4b
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetInline-InLeftAlign-indent=4.hs
@@ -0,0 +1,88 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+    in  a + 2
+
+let_single_sig =
+    let a :: Int
+        a = 1
+    in  a + 2
+
+let_multi =
+    let a = 1
+        b = 2
+    in  a + b
+
+let_single_newline =
+    let a = 1
+    in  a + 2
+
+let_multi_newline =
+    let a = 1
+        b = 2
+    in  a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let d = "hello"
+        e = "world"
+     in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let b = 2
+          c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let b = 2
+                  c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let b = 2
+              c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=2.hs b/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=2.hs
new file mode 100644
index 0000000..4ca5733
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=2.hs
@@ -0,0 +1,88 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+   in a + 2
+
+let_single_sig =
+  let a :: Int
+      a = 1
+   in a + 2
+
+let_multi =
+  let a = 1
+      b = 2
+   in a + b
+
+let_single_newline =
+  let a = 1
+   in a + 2
+
+let_multi_newline =
+  let a = 1
+      b = 2
+   in a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let b = 2
+      c = 3
+
+  let d = "hello"
+   in print d
+
+  let d = "hello"
+      e = "world"
+   in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let b = 2
+        c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let b = 2
+            c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let b = 2
+          c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=4.hs b/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=4.hs
new file mode 100644
index 0000000..65ac0b9
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetInline-InRightAlign-indent=4.hs
@@ -0,0 +1,88 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+     in a + 2
+
+let_single_sig =
+    let a :: Int
+        a = 1
+     in a + 2
+
+let_multi =
+    let a = 1
+        b = 2
+     in a + b
+
+let_single_newline =
+    let a = 1
+     in a + 2
+
+let_multi_newline =
+    let a = 1
+        b = 2
+     in a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let d = "hello"
+        e = "world"
+     in print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let b = 2
+          c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let b = 2
+                  c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let b = 2
+              c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=2.hs b/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=2.hs
new file mode 100644
index 0000000..b544815
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=2.hs
@@ -0,0 +1,100 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+  in  a + 2
+
+let_single_sig =
+  let
+    a :: Int
+    a = 1
+  in
+    a + 2
+
+let_multi =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+let_single_newline =
+  let a = 1
+  in  a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let
+    b = 2
+    c = 3
+
+  let d = "hello"
+   in print d
+
+  let
+    d = "hello"
+    e = "world"
+   in
+    print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let
+      b = 2
+      c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let
+          b = 2
+          c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let
+        b = 2
+        c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=4.hs b/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=4.hs
new file mode 100644
index 0000000..e345ead
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetMixed-InLeftAlign-indent=4.hs
@@ -0,0 +1,100 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+    in  a + 2
+
+let_single_sig =
+    let
+        a :: Int
+        a = 1
+    in
+        a + 2
+
+let_multi =
+    let
+        a = 1
+        b = 2
+    in
+        a + b
+
+let_single_newline =
+    let a = 1
+    in  a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+    in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let
+        b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let
+        d = "hello"
+        e = "world"
+     in
+        print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let
+        b = 2
+        c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let
+                b = 2
+                c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let
+            b = 2
+            c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=2.hs b/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=2.hs
new file mode 100644
index 0000000..e2ae278
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=2.hs
@@ -0,0 +1,100 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let a = 1
+   in a + 2
+
+let_single_sig =
+  let
+    a :: Int
+    a = 1
+   in
+    a + 2
+
+let_multi =
+  let
+    a = 1
+    b = 2
+   in
+    a + b
+
+let_single_newline =
+  let a = 1
+   in a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+   in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let a = 1
+
+  let
+    b = 2
+    c = 3
+
+  let d = "hello"
+   in print d
+
+  let
+    d = "hello"
+    e = "world"
+   in
+    print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+  , let a = 1
+  , let
+      b = 2
+      c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+      , let a = 1
+      , let
+          b = 2
+          c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+    , let a = 1
+    , let
+        b = 2
+        c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=4.hs b/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=4.hs
new file mode 100644
index 0000000..1d04abd
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetMixed-InRightAlign-indent=4.hs
@@ -0,0 +1,100 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let a = 1
+     in a + 2
+
+let_single_sig =
+    let
+        a :: Int
+        a = 1
+     in
+        a + 2
+
+let_multi =
+    let
+        a = 1
+        b = 2
+     in
+        a + b
+
+let_single_newline =
+    let a = 1
+     in a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+     in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let a = 1
+
+    let
+        b = 2
+        c = 3
+
+    let d = "hello"
+     in print d
+
+    let
+        d = "hello"
+        e = "world"
+     in
+        print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+    , let a = 1
+    , let
+        b = 2
+        c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+            , let a = 1
+            , let
+                b = 2
+                c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+        , let a = 1
+        , let
+            b = 2
+            c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=2.hs b/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=2.hs
new file mode 100644
index 0000000..5fe5834
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=2.hs
@@ -0,0 +1,113 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let
+    a = 1
+  in
+    a + 2
+
+let_single_sig =
+  let
+    a :: Int
+    a = 1
+  in
+    a + 2
+
+let_multi =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+let_single_newline =
+  let
+    a = 1
+  in
+    a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+  in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let
+    a = 1
+
+  let
+    b = 2
+    c = 3
+
+  let
+    d = "hello"
+   in
+    print d
+
+  let
+    d = "hello"
+    e = "world"
+   in
+    print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+
+  , let
+      a = 1
+  , let
+      b = 2
+      c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+
+      , let
+          a = 1
+      , let
+          b = 2
+          c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+
+    , let
+        a = 1
+    , let
+        b = 2
+        c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=4.hs b/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=4.hs
new file mode 100644
index 0000000..a7da15b
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetNewline-InLeftAlign-indent=4.hs
@@ -0,0 +1,113 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let
+        a = 1
+    in
+        a + 2
+
+let_single_sig =
+    let
+        a :: Int
+        a = 1
+    in
+        a + 2
+
+let_multi =
+    let
+        a = 1
+        b = 2
+    in
+        a + b
+
+let_single_newline =
+    let
+        a = 1
+    in
+        a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+    in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let
+        a = 1
+
+    let
+        b = 2
+        c = 3
+
+    let
+        d = "hello"
+     in
+        print d
+
+    let
+        d = "hello"
+        e = "world"
+     in
+        print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+
+    , let
+        a = 1
+    , let
+        b = 2
+        c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+
+            , let
+                a = 1
+            , let
+                b = 2
+                c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+
+        , let
+            a = 1
+        , let
+            b = 2
+            c = 3
+        ]
diff --git a/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=2.hs b/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=2.hs
new file mode 100644
index 0000000..d41240c
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=2.hs
@@ -0,0 +1,113 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+  let a = 1 in a + 2
+
+let_oneline_multi =
+  let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+  let
+    a = 1
+   in
+    a + 2
+
+let_single_sig =
+  let
+    a :: Int
+    a = 1
+   in
+    a + 2
+
+let_multi =
+  let
+    a = 1
+    b = 2
+   in
+    a + b
+
+let_single_newline =
+  let
+    a = 1
+   in
+    a + 2
+
+let_multi_newline =
+  let
+    a = 1
+    b = 2
+   in
+    a + b
+
+{-- do-block --}
+
+test_do = do
+  -- TODO: https://github.com/tweag/ormolu/issues/917
+  -- let
+
+  let
+    a = 1
+
+  let
+    b = 2
+    c = 3
+
+  let
+    d = "hello"
+   in
+    print d
+
+  let
+    d = "hello"
+    e = "world"
+   in
+    print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+  [ x + a + b + c
+  | x <- xs
+  , let
+
+  , let
+      a = 1
+  , let
+      b = 2
+      c = 2
+  ]
+
+test_list_do = do
+  x <-
+    [ x + a + b + c
+      | x <- xs
+      , let
+
+      , let
+          a = 1
+      , let
+          b = 2
+          c = 3
+      ]
+
+  [ x + y + a + b + c
+    | y <- ys
+    , let
+
+    , let
+        a = 1
+    , let
+        b = 2
+        c = 3
+    ]
diff --git a/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=4.hs b/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=4.hs
new file mode 100644
index 0000000..474580b
--- /dev/null
+++ b/data/fourmolu/let-style/output-LetNewline-InRightAlign-indent=4.hs
@@ -0,0 +1,113 @@
+{-- should be the same in every option --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_oneline_empty =
+--   let in 10
+
+let_oneline_single =
+    let a = 1 in a + 2
+
+let_oneline_multi =
+    let a = 1; b = 2 in a + b
+
+{-- pure let expressions --}
+
+-- TODO: https://github.com/tweag/ormolu/issues/917
+-- let_empty =
+--   let
+--   in  10
+
+let_single =
+    let
+        a = 1
+     in
+        a + 2
+
+let_single_sig =
+    let
+        a :: Int
+        a = 1
+     in
+        a + 2
+
+let_multi =
+    let
+        a = 1
+        b = 2
+     in
+        a + b
+
+let_single_newline =
+    let
+        a = 1
+     in
+        a + 2
+
+let_multi_newline =
+    let
+        a = 1
+        b = 2
+     in
+        a + b
+
+{-- do-block --}
+
+test_do = do
+    -- TODO: https://github.com/tweag/ormolu/issues/917
+    -- let
+
+    let
+        a = 1
+
+    let
+        b = 2
+        c = 3
+
+    let
+        d = "hello"
+     in
+        print d
+
+    let
+        d = "hello"
+        e = "world"
+     in
+        print (d ++ e)
+
+{-- list comprehension --}
+
+test_list =
+    [ x + a + b + c
+    | x <- xs
+    , let
+
+    , let
+        a = 1
+    , let
+        b = 2
+        c = 2
+    ]
+
+test_list_do = do
+    x <-
+        [ x + a + b + c
+            | x <- xs
+            , let
+
+            , let
+                a = 1
+            , let
+                b = 2
+                c = 3
+            ]
+
+    [ x + y + a + b + c
+        | y <- ys
+        , let
+
+        , let
+            a = 1
+        , let
+            b = 2
+            c = 3
+        ]
diff --git a/expected-failures/lens.txt b/expected-failures/lens.txt
new file mode 100644
index 0000000..fe39836
--- /dev/null
+++ b/expected-failures/lens.txt
@@ -0,0 +1,4 @@
+Found .cabal file lens-properties/lens-properties.cabal, but it did not mention lens-properties/Setup.hs
+tests/properties.hs:121:26-28
+  The GHC parser (in Haddock mode) failed:
+  parse error on input `KVS'
diff --git a/expected-failures/pandoc.txt b/expected-failures/pandoc.txt
new file mode 100644
index 0000000..41557eb
--- /dev/null
+++ b/expected-failures/pandoc.txt
@@ -0,0 +1,30 @@
+Found .cabal file pandoc.cabal, but it did not mention Setup.hs
+src/Text/Pandoc/Readers/Org/Inlines.hs
+@@ -182,7 +182,8 @@
+    cs' <- cs
+    case cs' of
+      [] -> return []
+-     (d : ds) -> -- TODO needs refinement
++     (d : ds) ->
++       -- TODO needs refinement
+        case sty of
+          TextStyle ->
+            return $
+
+  Formatting is not idempotent.
+  Please, consider reporting the bug.
+src/Text/Pandoc/Readers/RST.hs
+@@ -1120,7 +1120,7 @@
+              -- if no ":class:" field is given, the default is the role name
+              classFieldClasses = maybe [role] T.words (lookup "class" fields)
+-             -- nub in case role name & language class are the same
+-          in nub (classFieldClasses ++ codeLanguageClass ++ oldClasses)
++          in -- nub in case role name & language class are the same
++             nub (classFieldClasses ++ codeLanguageClass ++ oldClasses)
+
+        attr =
+          let (ident, baseClasses, keyValues) = baseAttr
+
+  Formatting is not idempotent.
+  Please, consider reporting the bug.
+Found .cabal file pandoc.cabal, but it did not mention test/command/3510-src.hs
diff --git a/expected-failures/purescript.txt b/expected-failures/purescript.txt
new file mode 100644
index 0000000..fc8cefa
--- /dev/null
+++ b/expected-failures/purescript.txt
@@ -0,0 +1,42 @@
+Found .cabal file purescript.cabal, but it did not mention Setup.hs
+src/Language/PureScript/CoreFn/CSE.hs
+@@ -218,11 +218,12 @@
+    at d . non mempty . at e %%<~ \case
+      Nothing -> freshIdent (nameHint e) <&> \ident -> ((True, ident), Just ident)
+      Just ident -> pure ((False, ident), Just ident)
++   where
+      -- A reminder: as with %%=, the first element of the returned pair is the
+      -- final result of the expression, and the second element is the value to
+      -- stuff back through the lens into the state. (The difference is that %%<~
+      -- enables doing monadic work in the RHS, namely `freshIdent` here.)
+-   where
++
+      nameHint = \case
+        App _ v1 v2
+          | Var _ n <- v1,
+
+  Formatting is not idempotent.
+  Please, consider reporting the bug.
+src/Language/PureScript/CoreFn/Laziness.hs
+@@ -527,12 +527,12 @@
+                          makeForceCall ann ident'
+                    q -> Var ann q
+             in (ident, rewriteExpr <$> item)
+-           -- All that's left to do is run the above replacement on every item,
+-           -- translate items from our `RecursiveGroupItem` representation back into the
+-           -- form CoreFn expects, and inform the caller whether we made any laziness
+-           -- transformations after all. (That last bit of information is used to
+-           -- determine if the runtime factory function needs to be injected.)
+-    in (uncurry fromRGI . replaceReferencesWithForceCall <$> items, Any . not $ IM.null replacements)
++    in -- All that's left to do is run the above replacement on every item,
++       -- translate items from our `RecursiveGroupItem` representation back into the
++       -- form CoreFn expects, and inform the caller whether we made any laziness
++       -- transformations after all. (That last bit of information is used to
++       -- determine if the runtime factory function needs to be injected.)
++       (uncurry fromRGI . replaceReferencesWithForceCall <$> items, Any . not $ IM.null replacements)
+    where
+      nullAnn = ssAnn nullSourceSpan
+      runtimeLazy = Var nullAnn . Qualified ByNullSourcePos $ InternalIdent RuntimeLazyFactory
+
+  Formatting is not idempotent.
+  Please, consider reporting the bug.
diff --git a/fourmolu.cabal b/fourmolu.cabal
index 2b01af7..e0b4a5b 100644
--- a/fourmolu.cabal
+++ b/fourmolu.cabal
@@ -100,7 +100,7 @@ library
     other-modules:    GHC.DynFlags
     default-language: Haskell2010
     build-depends:
-        Cabal >=3.6 && <3.7,
+        Cabal-syntax >=3.8 && <3.9,
         Diff >=0.4 && <1.0,
         MemoTrie >=0.6 && <0.7,
         aeson >=1.0 && <3.0,
@@ -113,7 +113,7 @@ library
         dlist >=0.8 && <2.0,
         exceptions >=0.6 && <0.11,
         filepath >=1.2 && <1.5,
-        ghc-lib-parser >=9.2 && <9.3,
+        ghc-lib-parser >=9.4 && <9.5,
         megaparsec >=9.0,
         mtl >=2.0 && <3.0,
         syb >=0.7 && <0.8,
@@ -150,7 +150,7 @@ executable fourmolu
         base >=4.12 && <5.0,
         containers >=0.5 && <0.7,
         filepath >=1.2 && <1.5,
-        ghc-lib-parser >=9.2 && <9.3,
+        ghc-lib-parser >=9.4 && <9.5,
         gitrev >=1.3 && <1.4,
         optparse-applicative >=0.14 && <0.18,
         text >=0.2 && <3.0,
@@ -201,7 +201,7 @@ test-suite tests
         containers >=0.5 && <0.7,
         directory ^>=1.3,
         filepath >=1.2 && <1.5,
-        ghc-lib-parser >=9.2 && <9.3,
+        ghc-lib-parser >=9.4 && <9.5,
         hspec >=2.0 && <3.0,
         hspec-megaparsec >=2.2,
         megaparsec >=9.0,
diff --git a/fourmolu.yaml b/fourmolu.yaml
index 905a26d..ae3f891 100644
--- a/fourmolu.yaml
+++ b/fourmolu.yaml
@@ -7,5 +7,7 @@ indent-wheres: true
 record-brace-space: true
 newlines-between-decls: 1
 haddock-style: single-line
+let-style: inline
+in-style: right-align
 respectful: false
 fixities: []
diff --git a/src/GHC/DynFlags.hs b/src/GHC/DynFlags.hs
index edb243d..5c4a4c5 100644
--- a/src/GHC/DynFlags.hs
+++ b/src/GHC/DynFlags.hs
@@ -38,6 +38,7 @@ fakeSettings =
             platformIsCrossCompiling = False,
             platformLeadingUnderscore = False,
             platformTablesNextToCode = False,
+            platformHasLibm = False,
             platform_constants = Nothing
           },
       sPlatformMisc = PlatformMisc {},
diff --git a/src/Ormolu/Config.hs b/src/Ormolu/Config.hs
index cca15e5..65775ec 100644
--- a/src/Ormolu/Config.hs
+++ b/src/Ormolu/Config.hs
@@ -35,6 +35,8 @@ module Ormolu.Config
     CommaStyle (..),
     HaddockPrintStyle (..),
     ImportExportStyle (..),
+    LetStyle (..),
+    InStyle (..),
 
     -- ** Loading Fourmolu configuration
     loadConfigFile,
@@ -225,6 +227,8 @@ overFieldsM f $(unpackFieldsWithSuffix 'PrinterOpts "0") = do
   poRecordBraceSpace <- f poRecordBraceSpace0
   poNewlinesBetweenDecls <- f poNewlinesBetweenDecls0
   poHaddockStyle <- f poHaddockStyle0
+  poLetStyle <- f poLetStyle0
+  poInStyle <- f poInStyle0
   poRespectful <- f poRespectful0
   return PrinterOpts {..}
 
@@ -339,6 +343,25 @@ printerOptsMeta =
                 (showAllValues haddockPrintStyleMap),
             metaDefault = HaddockMultiLine
           },
+      poLetStyle =
+        PrinterOptsFieldMeta
+          { metaName = "let-style",
+            metaGetField = poLetStyle,
+            metaPlaceholder = "STYLE",
+            metaHelp =
+              printf
+                "Styling of let blocks (choices: %s)"
+                (showAllValues letStyleMap),
+            metaDefault = LetAuto
+          },
+      poInStyle =
+        PrinterOptsFieldMeta
+          { metaName = "in-style",
+            metaGetField = poInStyle,
+            metaPlaceholder = "STYLE",
+            metaHelp = "How to align the 'in' keyword with respect to the 'let' keyword",
+            metaDefault = InRightAlign
+          },
       poRespectful =
         PrinterOptsFieldMeta
           { metaName = "respectful",
@@ -408,6 +431,24 @@ importExportStyleMap =
       ]
    )
 
+letStyleMap :: BijectiveMap LetStyle
+letStyleMap =
+  $( mkBijectiveMap
+      [ ('LetAuto, "auto"),
+        ('LetInline, "inline"),
+        ('LetNewline, "newline"),
+        ('LetMixed, "mixed")
+      ]
+   )
+
+inStyleMap :: BijectiveMap InStyle
+inStyleMap =
+  $( mkBijectiveMap
+      [ ('InLeftAlign, "left-align"),
+        ('InRightAlign, "right-align")
+      ]
+   )
+
 instance PrinterOptsFieldType CommaStyle where
   parseJSON = parseJSONWith commaStyleMap "CommaStyle"
   parseText = parseTextWith commaStyleMap
@@ -428,6 +469,16 @@ instance PrinterOptsFieldType ImportExportStyle where
   parseText = parseTextWith importExportStyleMap
   showText = show . showTextWith importExportStyleMap
 
+instance PrinterOptsFieldType LetStyle where
+  parseJSON = parseJSONWith letStyleMap "LetStyle"
+  parseText = parseTextWith letStyleMap
+  showText = show . showTextWith letStyleMap
+
+instance PrinterOptsFieldType InStyle where
+  parseJSON = parseJSONWith inStyleMap "InStyle"
+  parseText = parseTextWith inStyleMap
+  showText = show . showTextWith inStyleMap
+
 ----------------------------------------------------------------------------
 -- BijectiveMap helpers
 
diff --git a/src/Ormolu/Config/Types.hs b/src/Ormolu/Config/Types.hs
index 8794f8e..09d5bde 100644
--- a/src/Ormolu/Config/Types.hs
+++ b/src/Ormolu/Config/Types.hs
@@ -7,6 +7,8 @@ module Ormolu.Config.Types
     FunctionArrowsStyle (..),
     HaddockPrintStyle (..),
     ImportExportStyle (..),
+    LetStyle (..),
+    InStyle (..),
   )
 where
 
@@ -30,6 +32,10 @@ data PrinterOpts f = PrinterOpts
     poNewlinesBetweenDecls :: f Int,
     -- | How to print doc comments
     poHaddockStyle :: f HaddockPrintStyle,
+    -- | Styling of let blocks
+    poLetStyle :: f LetStyle,
+    -- | How to align in keyword
+    poInStyle :: f InStyle,
     -- | Be less opinionated about spaces/newlines etc.
     poRespectful :: f Bool
   }
@@ -56,3 +62,15 @@ data ImportExportStyle
   | ImportExportTrailing
   | ImportExportDiffFriendly
   deriving (Eq, Show, Enum, Bounded)
+
+data LetStyle
+  = LetAuto
+  | LetInline
+  | LetNewline
+  | LetMixed
+  deriving (Eq, Show, Enum, Bounded)
+
+data InStyle
+  = InLeftAlign
+  | InRightAlign
+  deriving (Eq, Show, Enum, Bounded)
diff --git a/src/Ormolu/Diff/ParseResult.hs b/src/Ormolu/Diff/ParseResult.hs
index aa4faf9..e891905 100644
--- a/src/Ormolu/Diff/ParseResult.hs
+++ b/src/Ormolu/Diff/ParseResult.hs
@@ -1,9 +1,13 @@
 {-# LANGUAGE BangPatterns #-}
--- needed on GHC 9.0 due to simplified subsumption
-{-# LANGUAGE ImpredicativeTypes #-}
+{-# LANGUAGE CPP #-}
+{-# LANGUAGE RankNTypes #-}
 {-# LANGUAGE RecordWildCards #-}
 {-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE ViewPatterns #-}
+#if !MIN_VERSION_base(4,17,0)
+-- needed on GHC 9.0 and 9.2 due to simplified subsumption
+{-# LANGUAGE ImpredicativeTypes #-}
+#endif
 
 -- | This module allows us to diff two 'ParseResult's.
 module Ormolu.Diff.ParseResult
@@ -146,7 +150,7 @@ matchIgnoringSrcSpans a = genericQuery a
     -- as we normalize arrow styles (e.g. -> vs →), we consider them equal here
     unicodeArrowStyleEq :: HsArrow GhcPs -> GenericQ ParseResultDiff
     unicodeArrowStyleEq (HsUnrestrictedArrow _) (castArrow -> Just (HsUnrestrictedArrow _)) = Same
-    unicodeArrowStyleEq (HsLinearArrow _ _) (castArrow -> Just (HsLinearArrow _ _)) = Same
+    unicodeArrowStyleEq (HsLinearArrow _) (castArrow -> Just (HsLinearArrow _)) = Same
     unicodeArrowStyleEq (HsExplicitMult _ _ t) (castArrow -> Just (HsExplicitMult _ _ t')) = genericQuery t t'
     unicodeArrowStyleEq _ _ = Different []
     castArrow :: Typeable a => a -> Maybe (HsArrow GhcPs)
diff --git a/src/Ormolu/Exception.hs b/src/Ormolu/Exception.hs
index 622915e..6397c74 100644
--- a/src/Ormolu/Exception.hs
+++ b/src/Ormolu/Exception.hs
@@ -4,6 +4,7 @@
 -- | 'OrmoluException' type and surrounding definitions.
 module Ormolu.Exception
   ( OrmoluException (..),
+    printOrmoluException,
     withPrettyOrmoluExceptions,
   )
 where
diff --git a/src/Ormolu/Imports.hs b/src/Ormolu/Imports.hs
index 4b03911..f6859e8 100644
--- a/src/Ormolu/Imports.hs
+++ b/src/Ormolu/Imports.hs
@@ -20,6 +20,7 @@ import GHC.Data.FastString
 import GHC.Hs
 import GHC.Hs.ImpExp as GHC
 import GHC.Types.Name.Reader
+import GHC.Types.PkgQual
 import GHC.Types.SourceText
 import GHC.Types.SrcLoc
 import GHC.Unit.Module.Name
@@ -91,7 +92,7 @@ importId (L _ ImportDecl {..}) =
   ImportId
     { importIsPrelude = isPrelude,
       importIdName = moduleName,
-      importPkgQual = LexicalFastString . sl_fs <$> ideclPkgQual,
+      importPkgQual = rawPkgQualToLFS ideclPkgQual,
       importSource = ideclSource,
       importSafe = ideclSafe,
       importQualified = case ideclQualified of
@@ -105,6 +106,9 @@ importId (L _ ImportDecl {..}) =
   where
     isPrelude = moduleNameString moduleName == "Prelude"
     moduleName = unLoc ideclName
+    rawPkgQualToLFS = \case
+      RawPkgQual fs -> Just . LexicalFastString . sl_fs $ fs
+      NoRawPkgQual -> Nothing
 
 -- | Normalize a collection of import\/export items.
 normalizeLies :: [LIE GhcPs] -> [LIE GhcPs]
diff --git a/src/Ormolu/Parser.hs b/src/Ormolu/Parser.hs
index 98ca45e..80003bd 100644
--- a/src/Ormolu/Parser.hs
+++ b/src/Ormolu/Parser.hs
@@ -19,23 +19,24 @@ import Data.Functor
 import Data.Generics
 import qualified Data.List as L
 import qualified Data.List.NonEmpty as NE
-import Data.Ord (Down (Down))
 import GHC.Data.Bag (bagToList)
 import qualified GHC.Data.EnumSet as EnumSet
 import qualified GHC.Data.FastString as GHC
 import qualified GHC.Data.StringBuffer as GHC
 import qualified GHC.Driver.CmdLine as GHC
+import GHC.Driver.Config.Parser (initParserOpts)
 import GHC.Driver.Session as GHC
 import GHC.DynFlags (baseDynFlags)
 import GHC.Hs hiding (UnicodeSyntax)
 import GHC.LanguageExtensions.Type (Extension (..))
 import qualified GHC.Parser as GHC
-import GHC.Parser.Errors.Ppr (pprError)
 import qualified GHC.Parser.Header as GHC
 import qualified GHC.Parser.Lexer as GHC
+import GHC.Types.Error (getMessages)
 import qualified GHC.Types.SourceError as GHC (handleSourceError)
 import GHC.Types.SrcLoc
-import GHC.Utils.Error (Severity (..), errMsgSeverity, errMsgSpan)
+import GHC.Utils.Error
+import GHC.Utils.Outputable (defaultSDocContext)
 import qualified GHC.Utils.Panic as GHC
 import Ormolu.Config
 import Ormolu.Exception
@@ -44,7 +45,7 @@ import Ormolu.Parser.CommentStream
 import Ormolu.Parser.Result
 import Ormolu.Processing.Common
 import Ormolu.Processing.Preprocess
-import Ormolu.Utils (incSpanLine)
+import Ormolu.Utils (incSpanLine, showOutputable)
 
 -- | Parse a complete module from string.
 parseModule ::
@@ -98,13 +99,22 @@ parseModuleSnippet ::
 parseModuleSnippet Config {..} fixityMap dynFlags path rawInput = liftIO $ do
   let (input, indent) = removeIndentation . linesInRegion cfgRegion $ rawInput
   let pStateErrors pstate =
-        let errs = fmap pprError . bagToList $ GHC.getErrorMessages pstate
+        let errs = bagToList . getMessages $ GHC.getPsErrorMessages pstate
             fixupErrSpan = incSpanLine (regionPrefixLength cfgRegion)
-         in case L.sortOn (Down . SeverityOrd . errMsgSeverity) errs of
+            rateSeverity = \case
+              SevError -> 1 :: Int
+              SevWarning -> 2
+              SevIgnore -> 3
+            showErr =
+              showOutputable
+                . formatBulleted defaultSDocContext
+                . diagnosticMessage
+                . errMsgDiagnostic
+         in case L.sortOn (rateSeverity . errMsgSeverity) errs of
               [] -> Nothing
               err : _ ->
                 -- Show instance returns a short error message
-                Just (fixupErrSpan (errMsgSpan err), show err)
+                Just (fixupErrSpan (errMsgSpan err), showErr err)
       parser = case cfgSourceType of
         ModuleSource -> GHC.parseModule
         SignatureSource -> GHC.parseSignature
@@ -149,12 +159,12 @@ normalizeModule hsmod =
         hsmodDecls =
           filter (not . isBlankDocD . unLoc) (hsmodDecls hsmod),
         hsmodHaddockModHeader =
-          mfilter (not . isBlankDocString . unLoc) (hsmodHaddockModHeader hsmod),
+          mfilter (not . isBlankDocString) (hsmodHaddockModHeader hsmod),
         hsmodExports =
           (fmap . fmap) (filter (not . isBlankDocIE . unLoc)) (hsmodExports hsmod)
       }
   where
-    isBlankDocString = all isSpace . unpackHDS
+    isBlankDocString = all isSpace . renderHsDocString . hsDocString . unLoc
     isBlankDocD = \case
       DocD _ s -> isBlankDocString $ docDeclDoc s
       _ -> False
@@ -164,8 +174,8 @@ normalizeModule hsmod =
       _ -> False
 
     dropBlankTypeHaddocks = \case
-      L _ (HsDocTy _ ty (L _ ds)) :: LHsType GhcPs
-        | isBlankDocString ds -> ty
+      L _ (HsDocTy _ ty s) :: LHsType GhcPs
+        | isBlankDocString s -> ty
       a -> a
 
 -- | Enable all language extensions that we think should be enabled by
@@ -223,34 +233,7 @@ runParser parser flags filename input = GHC.unP parser parseState
   where
     location = mkRealSrcLoc (GHC.mkFastString filename) 1 1
     buffer = GHC.stringToStringBuffer input
-    parseState = GHC.initParserState (opts flags) buffer location
-    opts =
-      GHC.mkParserOpts
-        <$> GHC.warningFlags
-        <*> GHC.extensionFlags
-        <*> GHC.safeImportsOn
-        <*> GHC.gopt GHC.Opt_Haddock
-        <*> GHC.gopt GHC.Opt_KeepRawTokenStream
-        <*> const True
-
--- | Wrap GHC's 'Severity' to add 'Ord' instance.
-newtype SeverityOrd = SeverityOrd Severity
-
-instance Eq SeverityOrd where
-  s1 == s2 = compare s1 s2 == EQ
-
-instance Ord SeverityOrd where
-  compare (SeverityOrd s1) (SeverityOrd s2) =
-    compare (f s1) (f s2)
-    where
-      f :: Severity -> Int
-      f SevOutput = 1
-      f SevFatal = 2
-      f SevInteractive = 3
-      f SevDump = 4
-      f SevInfo = 5
-      f SevWarning = 6
-      f SevError = 7
+    parseState = GHC.initParserState (initParserOpts flags) buffer location
 
 ----------------------------------------------------------------------------
 -- Helpers taken from HLint
@@ -267,7 +250,11 @@ parsePragmasIntoDynFlags ::
   IO (Either String ([GHC.Warn], DynFlags))
 parsePragmasIntoDynFlags flags extraOpts filepath str =
   catchErrors $ do
-    let fileOpts = GHC.getOptions flags (GHC.stringToStringBuffer str) filepath
+    let (_warnings, fileOpts) =
+          GHC.getOptions
+            (initParserOpts flags)
+            (GHC.stringToStringBuffer str)
+            filepath
     (flags', leftovers, warnings) <-
       parseDynamicFilePragma flags (extraOpts <> fileOpts)
     case NE.nonEmpty leftovers of
diff --git a/src/Ormolu/Parser/CommentStream.hs b/src/Ormolu/Parser/CommentStream.hs
index 9b4c0e3..097c208 100644
--- a/src/Ormolu/Parser/CommentStream.hs
+++ b/src/Ormolu/Parser/CommentStream.hs
@@ -29,8 +29,8 @@ import qualified Data.List.NonEmpty as NE
 import qualified Data.Map.Lazy as M
 import Data.Maybe
 import qualified Data.Set as S
+import qualified GHC.Data.Strict as Strict
 import GHC.Hs (HsModule)
-import GHC.Hs.Decls (HsDecl (..), LDocDecl, LHsDecl)
 import GHC.Hs.Doc
 import GHC.Hs.Extension
 import GHC.Hs.ImpExp
@@ -87,22 +87,15 @@ mkCommentStream input hsModule =
               EpaComments cs -> cs
               EpaCommentsBalanced pcs fcs -> pcs <> fcs
         -- All spans of valid Haddock comments
-        -- (everywhere where we use p_hsDoc{String,Name})
         validHaddockCommentSpans =
           S.fromList
             . mapMaybe srcSpanToRealSrcSpan
             . mconcat
-              [ fmap getLoc . listify (only @LHsDocString),
-                fmap getLocA . listify (only @(LDocDecl GhcPs)),
-                fmap getLocA . listify isDocD,
+              [ fmap getLoc . listify (only @(LHsDoc GhcPs)),
                 fmap getLocA . listify isIEDocLike
               ]
             $ hsModule
           where
-            isDocD :: LHsDecl GhcPs -> Bool
-            isDocD = \case
-              L _ DocD {} -> True
-              _ -> False
             isIEDocLike :: LIE GhcPs -> Bool
             isIEDocLike = \case
               L _ IEGroup {} -> True
@@ -231,8 +224,8 @@ extractPragmas input = go initialLs id id
                   (y : ys) ->
                     let (ls', y') = mkComment ls y
                      in if onTheSameLine
-                          (RealSrcSpan (getRealSrcSpan x) Nothing)
-                          (RealSrcSpan (getRealSrcSpan y) Nothing)
+                          (RealSrcSpan (getRealSrcSpan x) Strict.Nothing)
+                          (RealSrcSpan (getRealSrcSpan y) Strict.Nothing)
                           then go' ls' [y'] ys
                           else go' ls [] xs
 
@@ -240,10 +233,13 @@ extractPragmas input = go initialLs id id
 unAnnotationComment :: GHC.LEpaComment -> Maybe (RealLocated String)
 unAnnotationComment (L (GHC.Anchor anchor _) (GHC.EpaComment eck _)) =
   case eck of
-    GHC.EpaDocCommentNext s -> haddock "|" s -- @-- |@
-    GHC.EpaDocCommentPrev s -> haddock "^" s -- @-- ^@
-    GHC.EpaDocCommentNamed s -> haddock "$" s -- @-- $@
-    GHC.EpaDocSection k s -> haddock (replicate k '*') s -- @-- *@
+    GHC.EpaDocComment s ->
+      let trigger = case s of
+            MultiLineDocString t _ -> Just t
+            NestedDocString t _ -> Just t
+            -- should not occur
+            GeneratedDocString _ -> Nothing
+       in haddock trigger (renderHsDocString s)
     GHC.EpaDocOptions s -> mkL s
     GHC.EpaLineComment s -> mkL $
       case take 3 s of
@@ -255,9 +251,15 @@ unAnnotationComment (L (GHC.Anchor anchor _) (GHC.EpaComment eck _)) =
   where
     mkL = Just . L anchor
     insertAt x xs n = take (n - 1) xs ++ x ++ drop (n - 1) xs
-    haddock trigger =
+    haddock mtrigger =
       mkL . dashPrefix . escapeHaddockTriggers . (trigger <>) <=< dropBlank
       where
+        trigger = case mtrigger of
+          Just HsDocStringNext -> "|"
+          Just HsDocStringPrevious -> "^"
+          Just (HsDocStringNamed n) -> "$" <> n
+          Just (HsDocStringGroup k) -> replicate k '*'
+          Nothing -> ""
         dashPrefix s = "--" <> spaceIfNecessary <> s
           where
             spaceIfNecessary = case s of
diff --git a/src/Ormolu/Parser/Pragma.hs b/src/Ormolu/Parser/Pragma.hs
index 3f9c1ca..0f38e2a 100644
--- a/src/Ormolu/Parser/Pragma.hs
+++ b/src/Ormolu/Parser/Pragma.hs
@@ -11,9 +11,10 @@ where
 import Control.Monad
 import Data.Char (isSpace, toLower)
 import qualified Data.List as L
-import qualified GHC.Data.EnumSet as ES
 import GHC.Data.FastString (mkFastString, unpackFS)
 import GHC.Data.StringBuffer
+import GHC.Driver.Config.Parser (initParserOpts)
+import GHC.DynFlags (baseDynFlags)
 import qualified GHC.Parser.Lexer as L
 import GHC.Types.SrcLoc
 
@@ -67,14 +68,7 @@ tokenize input =
     location = mkRealSrcLoc (mkFastString "") 1 1
     buffer = stringToStringBuffer input
     parseState = L.initParserState parserOpts buffer location
-    parserOpts =
-      L.mkParserOpts
-        ES.empty
-        ES.empty
-        True
-        True
-        True
-        True
+    parserOpts = initParserOpts baseDynFlags
 
 -- | Haskell lexer.
 pLexer :: L.P [L.Token]
diff --git a/src/Ormolu/Printer/Combinators.hs b/src/Ormolu/Printer/Combinators.hs
index c0c88de..f6e9f56 100644
--- a/src/Ormolu/Printer/Combinators.hs
+++ b/src/Ormolu/Printer/Combinators.hs
@@ -85,6 +85,7 @@ where
 import Control.Monad
 import Data.List (intersperse)
 import Data.Text (Text)
+import qualified GHC.Data.Strict as Strict
 import GHC.Types.SrcLoc
 import Ormolu.Config
 import Ormolu.Config.Types (FunctionArrowsStyle (..))
@@ -121,7 +122,7 @@ located (L l' a) f = case loc' l' of
   RealSrcSpan l _ -> do
     spitPrecedingComments l
     withEnclosingSpan l $
-      switchLayout [RealSrcSpan l Nothing] (f a)
+      switchLayout [RealSrcSpan l Strict.Nothing] (f a)
     spitFollowingComments l
 
 -- | A version of 'located' with arguments flipped.
diff --git a/src/Ormolu/Printer/Meat/Common.hs b/src/Ormolu/Printer/Meat/Common.hs
index 5108ee2..f89d378 100644
--- a/src/Ormolu/Printer/Meat/Common.hs
+++ b/src/Ormolu/Printer/Meat/Common.hs
@@ -10,6 +10,7 @@ module Ormolu.Printer.Meat.Common
     p_rdrName,
     p_qualName,
     p_infixDefHelper,
+    p_hsDoc,
     p_hsDocString,
     p_sourceText,
   )
@@ -20,6 +21,7 @@ import Data.Foldable (traverse_)
 import Data.List (intersperse)
 import qualified Data.Text as T
 import GHC.Hs.Doc
+import GHC.Hs.Extension (GhcPs)
 import GHC.Hs.ImpExp
 import GHC.Parser.Annotation
 import GHC.Types.Name.Occurrence (OccName (..))
@@ -131,6 +133,18 @@ p_infixDefHelper isInfix indentArgs name args =
         breakpoint
         inciIf indentArgs $ sitcc (sep breakpoint sitcc args)
 
+-- | Print a Haddock.
+p_hsDoc ::
+  -- | Haddock style
+  HaddockStyle ->
+  -- | Finish the doc string with a newline
+  Bool ->
+  -- | The 'LHsDoc' to render
+  LHsDoc GhcPs ->
+  R ()
+p_hsDoc hstyle needsNewline =
+  p_hsDocString hstyle needsNewline . fmap hsDocString
+
 -- | Print a Haddock.
 p_hsDocString ::
   -- | Haddock style
diff --git a/src/Ormolu/Printer/Meat/Declaration.hs b/src/Ormolu/Printer/Meat/Declaration.hs
index 95386de..334478d 100644
--- a/src/Ormolu/Printer/Meat/Declaration.hs
+++ b/src/Ormolu/Printer/Meat/Declaration.hs
@@ -125,10 +125,10 @@ p_hsDecl style = \case
   SpliceD _ x -> p_spliceDecl x
   DocD _ docDecl ->
     case docDecl of
-      DocCommentNext str -> p_hsDocString Pipe False (noLoc str)
-      DocCommentPrev str -> p_hsDocString Caret False (noLoc str)
-      DocCommentNamed name str -> p_hsDocString (Named name) False (noLoc str)
-      DocGroup n str -> p_hsDocString (Asterisk n) False (noLoc str)
+      DocCommentNext str -> p_hsDoc Pipe False str
+      DocCommentPrev str -> p_hsDoc Caret False str
+      DocCommentNamed name str -> p_hsDoc (Named name) False str
+      DocGroup n str -> p_hsDoc (Asterisk n) False str
   RoleAnnotD _ x -> p_roleAnnot x
   KindSigD _ s -> p_standaloneKindSig s
 
@@ -314,7 +314,7 @@ patBindNames (VarPat _ (L _ n)) = [n]
 patBindNames (WildPat _) = []
 patBindNames (LazyPat _ (L _ p)) = patBindNames p
 patBindNames (BangPat _ (L _ p)) = patBindNames p
-patBindNames (ParPat _ (L _ p)) = patBindNames p
+patBindNames (ParPat _ _ (L _ p) _) = patBindNames p
 patBindNames (ListPat _ ps) = concatMap (patBindNames . unLoc) ps
 patBindNames (AsPat _ (L _ n) (L _ p)) = n : patBindNames p
 patBindNames (SumPat _ (L _ p) _ _) = patBindNames p
diff --git a/src/Ormolu/Printer/Meat/Declaration/Data.hs b/src/Ormolu/Printer/Meat/Declaration/Data.hs
index 7e45fe3..1a2d2e6 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Data.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Data.hs
@@ -14,6 +14,7 @@ import Control.Monad
 import Data.Maybe (isJust, maybeToList)
 import qualified Data.Text as Text
 import Data.Void
+import qualified GHC.Data.Strict as Strict
 import GHC.Hs
 import GHC.Types.Fixity
 import GHC.Types.ForeignCall
@@ -107,7 +108,7 @@ p_conDecl ::
   R ()
 p_conDecl singleConstRec = \case
   ConDeclGADT {..} -> do
-    mapM_ (p_hsDocString Pipe True) con_doc
+    mapM_ (p_hsDoc Pipe True) con_doc
     let conDeclSpn =
           fmap getLocA con_names
             <> [getLocA con_bndrs]
@@ -116,7 +117,7 @@ p_conDecl singleConstRec = \case
           where
             conArgsSpans = case con_g_args of
               PrefixConGADT xs -> getLocA . hsScaledThing <$> xs
-              RecConGADT x -> [getLocA x]
+              RecConGADT x _ -> [getLocA x]
     switchLayout conDeclSpn $ do
       case con_names of
         [] -> return ()
@@ -137,26 +138,28 @@ p_conDecl singleConstRec = \case
               PrefixConGADT xs ->
                 let go (HsScaled a b) t = addCLocAA t b (HsFunTy EpAnnNotUsed a b t)
                  in foldr go con_res_ty xs
-              RecConGADT r ->
+              RecConGADT r _ ->
                 addCLocAA r con_res_ty $
                   HsFunTy
                     EpAnnNotUsed
-                    (HsUnrestrictedArrow NormalSyntax)
+                    (HsUnrestrictedArrow noHsUniTok)
                     (la2la $ HsRecTy EpAnnNotUsed <$> r)
                     con_res_ty
             qualTy = case con_mb_cxt of
               Nothing -> conTy
               Just qs ->
                 addCLocAA qs conTy $
-                  HsQualTy NoExtField (Just qs) conTy
+                  HsQualTy NoExtField qs conTy
             quantifiedTy =
               addCLocAA con_bndrs qualTy $
                 hsOuterTyVarBndrsToHsType (unLoc con_bndrs) qualTy
         p_hsType (unLoc quantifiedTy)
   ConDeclH98 {..} -> do
-    mapM_ (p_hsDocString Pipe True) con_doc
+    mapM_ (p_hsDoc Pipe True) con_doc
     let conDeclWithContextSpn =
-          [RealSrcSpan real Nothing | AddEpAnn AnnForall (EpaSpan real) <- epAnnAnns con_ext]
+          [ RealSrcSpan real Strict.Nothing
+            | AddEpAnn AnnForall (EpaSpan real) <- epAnnAnns con_ext
+          ]
             <> fmap getLocA con_ex_tvs
             <> maybeToList (fmap getLocA con_mb_cxt)
             <> conDeclSpn
diff --git a/src/Ormolu/Printer/Meat/Declaration/Instance.hs b/src/Ormolu/Printer/Meat/Declaration/Instance.hs
index 5f5fe58..7f10b7a 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Instance.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Instance.hs
@@ -70,7 +70,7 @@ p_clsInstDecl ClsInstDecl {..} = do
         )
           <$> cid_tyfam_insts
       dataFamInsts =
-        ( getLocA &&& fmap (InstD NoExtField . DataFamInstD EpAnnNotUsed)
+        ( getLocA &&& fmap (InstD NoExtField . DataFamInstD NoExtField)
         )
           <$> cid_datafam_insts
       allDecls =
diff --git a/src/Ormolu/Printer/Meat/Declaration/OpTree.hs b/src/Ormolu/Printer/Meat/Declaration/OpTree.hs
index d91014c..62dfc6d 100644
--- a/src/Ormolu/Printer/Meat/Declaration/OpTree.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/OpTree.hs
@@ -229,7 +229,7 @@ tyOpPlacement = \case
 -- | Convert a LHsType containing an operator tree to the 'OpTree'
 -- intermediate representation.
 tyOpTree :: LHsType GhcPs -> OpTree (LHsType GhcPs) (LocatedN RdrName)
-tyOpTree (L _ (HsOpTy NoExtField l op r)) =
+tyOpTree (L _ (HsOpTy _ _ l op r)) =
   OpBranches [tyOpTree l, tyOpTree r] [op]
 tyOpTree n = OpNode n
 
diff --git a/src/Ormolu/Printer/Meat/Declaration/RoleAnnotation.hs b/src/Ormolu/Printer/Meat/Declaration/RoleAnnotation.hs
index b59222b..0d0d60d 100644
--- a/src/Ormolu/Printer/Meat/Declaration/RoleAnnotation.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/RoleAnnotation.hs
@@ -11,14 +11,13 @@ where
 import GHC.Core.Coercion.Axiom
 import GHC.Hs hiding (anns)
 import GHC.Types.Name.Reader
-import GHC.Types.SrcLoc
 import Ormolu.Printer.Combinators
 import Ormolu.Printer.Meat.Common
 
 p_roleAnnot :: RoleAnnotDecl GhcPs -> R ()
 p_roleAnnot (RoleAnnotDecl _ l_name anns) = p_roleAnnot' l_name anns
 
-p_roleAnnot' :: LocatedN RdrName -> [Located (Maybe Role)] -> R ()
+p_roleAnnot' :: LocatedN RdrName -> [XRec GhcPs (Maybe Role)] -> R ()
 p_roleAnnot' l_name anns = do
   txt "type role"
   breakpoint
diff --git a/src/Ormolu/Printer/Meat/Declaration/Rule.hs b/src/Ormolu/Printer/Meat/Declaration/Rule.hs
index 912275c..2cb1967 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Rule.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Rule.hs
@@ -36,7 +36,7 @@ p_ruleDecl (HsRule _ ruleName activation tyvars ruleBndrs lhs rhs) = do
   -- in the input or no forall at all. We do not want to add redundant
   -- foralls, so let's just skip the empty ones.
   unless (null ruleBndrs) $
-    p_forallBndrs ForAllInvis p_ruleBndr (reLocA <$> ruleBndrs)
+    p_forallBndrs ForAllInvis p_ruleBndr ruleBndrs
   breakpoint
   inci $ do
     located lhs p_hsExpr
diff --git a/src/Ormolu/Printer/Meat/Declaration/Signature.hs b/src/Ormolu/Printer/Meat/Declaration/Signature.hs
index 06fb585..31d6ab1 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Signature.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Signature.hs
@@ -145,9 +145,10 @@ p_specSig name ts InlinePragma {..} = pragmaBraces $ do
 
 p_inlineSpec :: InlineSpec -> R ()
 p_inlineSpec = \case
-  Inline -> txt "INLINE"
-  Inlinable -> txt "INLINEABLE"
-  NoInline -> txt "NOINLINE"
+  Inline _ -> txt "INLINE"
+  Inlinable _ -> txt "INLINEABLE"
+  NoInline _ -> txt "NOINLINE"
+  Opaque _ -> txt "OPAQUE"
   NoUserInlinePrag -> return ()
 
 p_activation :: Activation -> R ()
@@ -213,7 +214,7 @@ p_completeSig cs' mty =
         leadingArrowType
         inci (p_rdrName ty)
 
-p_sccSig :: LocatedN RdrName -> Maybe (Located StringLiteral) -> R ()
+p_sccSig :: LocatedN RdrName -> Maybe (XRec GhcPs StringLiteral) -> R ()
 p_sccSig loc literal = pragma "SCC" . inci $ do
   p_rdrName loc
   forM_ literal $ \x -> do
diff --git a/src/Ormolu/Printer/Meat/Declaration/TypeFamily.hs b/src/Ormolu/Printer/Meat/Declaration/TypeFamily.hs
index fca9c19..04c4d16 100644
--- a/src/Ormolu/Printer/Meat/Declaration/TypeFamily.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/TypeFamily.hs
@@ -28,7 +28,7 @@ p_famDecl style FamilyDecl {fdTyVars = HsQTvs {..}, ..} = do
     Associated -> mempty
     Free -> " family"
   let headerSpns = getLocA fdLName : (getLocA <$> hsq_explicit)
-      headerAndSigSpns = getLoc fdResultSig : headerSpns
+      headerAndSigSpns = getLocA fdResultSig : headerSpns
   inci . switchLayout headerAndSigSpns $ do
     breakpoint
     switchLayout headerSpns $ do
@@ -58,7 +58,7 @@ p_famDecl style FamilyDecl {fdTyVars = HsQTvs {..}, ..} = do
           inci (sep newline (located' p_tyFamInstEqn) eqs)
 
 p_familyResultSigL ::
-  Located (FamilyResultSig GhcPs) ->
+  LFamilyResultSig GhcPs ->
   Maybe (R ())
 p_familyResultSigL (L _ a) = case a of
   NoSig NoExtField -> Nothing
diff --git a/src/Ormolu/Printer/Meat/Declaration/Value.hs b/src/Ormolu/Printer/Meat/Declaration/Value.hs
index 192b828..c73dca6 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Value.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Value.hs
@@ -2,8 +2,10 @@
 {-# LANGUAGE NamedFieldPuns #-}
 {-# LANGUAGE OverloadedStrings #-}
 {-# LANGUAGE RecordWildCards #-}
+{-# LANGUAGE ScopedTypeVariables #-}
 {-# LANGUAGE TypeApplications #-}
 {-# LANGUAGE TypeFamilies #-}
+{-# LANGUAGE TypeOperators #-}
 {-# LANGUAGE ViewPatterns #-}
 
 module Ormolu.Printer.Meat.Declaration.Value
@@ -26,7 +28,7 @@ import Data.Data hiding (Infix, Prefix)
 import Data.Function (on)
 import Data.Functor ((<&>))
 import Data.Generics.Schemes (everything)
-import Data.List (intersperse, sortBy)
+import Data.List (find, intersperse, sortBy)
 import Data.List.NonEmpty (NonEmpty (..), (<|))
 import qualified Data.List.NonEmpty as NE
 import Data.Maybe
@@ -35,6 +37,7 @@ import qualified Data.Text as Text
 import Data.Void
 import GHC.Data.Bag (bagToList)
 import GHC.Data.FastString (FastString, lengthFS)
+import qualified GHC.Data.Strict as Strict
 import GHC.Hs
 import GHC.LanguageExtensions.Type (Extension (NegativeLiterals))
 import GHC.Parser.CharClass (is_space)
@@ -67,12 +70,11 @@ data GroupStyle
   = EqualSign
   | RightArrow
 
-p_valDecl :: HsBindLR GhcPs GhcPs -> R ()
+p_valDecl :: HsBind GhcPs -> R ()
 p_valDecl = \case
   FunBind _ funId funMatches _ -> p_funBind funId funMatches
   PatBind _ pat grhss _ -> p_match PatternBind False NoSrcStrict [pat] grhss
   VarBind {} -> notImplemented "VarBinds" -- introduced by the type checker
-  AbsBinds {} -> notImplemented "AbsBinds" -- introduced by the type checker
   PatSynBind _ psb -> p_patSynBind psb
 
 p_funBind ::
@@ -88,7 +90,7 @@ p_matchGroup ::
 p_matchGroup = p_matchGroup' exprPlacement p_hsExpr
 
 p_matchGroup' ::
-  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcSpan,
+  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcAnn NoEpAnns,
     Anno (Match GhcPs (LocatedA body)) ~ SrcSpanAnnA
   ) =>
   -- | How to get body placement
@@ -157,7 +159,7 @@ p_match ::
 p_match = p_match' exprPlacement p_hsExpr
 
 p_match' ::
-  (Anno (GRHS GhcPs (LocatedA body)) ~ SrcSpan) =>
+  (Anno (GRHS GhcPs (LocatedA body)) ~ SrcAnn NoEpAnns) =>
   -- | How to get body placement
   (body -> Placement) ->
   -- | How to print body
@@ -245,7 +247,7 @@ p_match' placer render style isInfix strictness m_pats GRHSs {..} = do
                 || not (onTheSameLine spn grhssSpan) ->
                 Normal
           _ -> blockPlacement placer grhssGRHSs
-      guardNeedsLineBreak :: Located (GRHS GhcPs body) -> Bool
+      guardNeedsLineBreak :: XRec GhcPs (GRHS GhcPs body) -> Bool
       guardNeedsLineBreak (L _ (GRHS _ guardLStmts _)) = case guardLStmts of
         [] -> False
         [g] -> not . isOneLineSpan . getLocA $ g
@@ -257,7 +259,7 @@ p_match' placer render style isInfix strictness m_pats GRHSs {..} = do
                 else EqualSign
         sep
           breakpoint
-          (located' (p_grhs' placement placer render groupStyle) . reLocA)
+          (located' (p_grhs' placement placer render groupStyle))
           grhssGRHSs
       p_where = do
         unless (eqEmptyLocalBinds grhssLocalBinds) $ do
@@ -357,15 +359,15 @@ p_hsCmd' s = \case
     space
     located expr p_hsExpr
   HsCmdLam _ mgroup -> p_matchGroup' cmdPlacement p_hsCmd Lambda mgroup
-  HsCmdPar _ c -> parens N $ sitcc $ located c p_hsCmd
+  HsCmdPar _ _ c _ -> parens N $ sitcc $ located c p_hsCmd
   HsCmdCase _ e mgroup ->
     p_case cmdPlacement p_hsCmd e mgroup
-  HsCmdLamCase _ mgroup ->
-    p_lamcase cmdPlacement p_hsCmd mgroup
+  HsCmdLamCase _ variant mgroup ->
+    p_lamcase variant cmdPlacement p_hsCmd mgroup
   HsCmdIf _ _ if' then' else' ->
     p_if cmdPlacement p_hsCmd if' then' else'
-  HsCmdLet _ localBinds c ->
-    p_let p_hsCmd localBinds c
+  HsCmdLet _ epAnnLet localBinds _ c ->
+    p_let (s == S) p_hsCmd epAnnLet localBinds c
   HsCmdDo _ es -> do
     txt "do"
     p_stmts cmdPlacement (p_hsCmd' S) es
@@ -431,10 +433,13 @@ p_stmt' placer render = \case
       placeHanging placement (located f render)
   ApplicativeStmt {} -> notImplemented "ApplicativeStmt" -- generated by renamer
   BodyStmt _ body _ _ -> located body render
-  LetStmt _ binds -> do
-    txt "let"
-    space
-    sitcc $ p_hsLocalBinds binds
+  LetStmt epAnnLet binds -> do
+    let letLoc =
+          fmap (\(AddEpAnn _ loc) -> loc)
+            . find (\(AddEpAnn ann _) -> ann == AnnLet)
+            . epAnnAnns
+            $ epAnnLet
+    p_let' True letLoc binds Nothing
   ParStmt {} ->
     -- 'ParStmt' should always be eliminated in 'gatherStmt' already, such
     -- that it never occurs in 'p_stmt''. Consequently, handling it here
@@ -527,16 +532,12 @@ p_hsLocalBinds = \case
     sitcc $ sepSemi p_item' (attachRelativePos binds)
   HsValBinds _ _ -> notImplemented "HsValBinds"
   HsIPBinds epAnn (IPBinds _ xs) -> pseudoLocated epAnn $ do
-    -- Second argument of IPBind is always Left before type-checking.
-    let p_ipBind (IPBind _ (Left name) expr) = do
-          atom name
+    let p_ipBind (IPBind _ (L _ name) expr) = do
+          atom @HsIPName name
           space
           equals
           breakpoint
           useBraces $ inci $ located expr p_hsExpr
-        p_ipBind (IPBind _ (Right _) _) =
-          -- Should only occur after the type checker
-          notImplemented "IPBind _ (Right _) _"
     sepSemi (located' p_ipBind) xs
   EmptyLocalBinds _ -> return ()
   where
@@ -545,13 +546,13 @@ p_hsLocalBinds = \case
     -- depend on the layout being correctly set.
     pseudoLocated = \case
       EpAnn {anns = AnnList {al_anchor = Just Anchor {anchor}}} ->
-        located (L (RealSrcSpan anchor Nothing) ()) . const
+        located (L (RealSrcSpan anchor Strict.Nothing) ()) . const
       _ -> id
 
-p_lhsFieldLabel :: Located (HsFieldLabel GhcPs) -> R ()
-p_lhsFieldLabel = located' $ p_lFieldLabelString . hflLabel
+p_ldotFieldOcc :: XRec GhcPs (DotFieldOcc GhcPs) -> R ()
+p_ldotFieldOcc = located' $ p_lFieldLabelString . dfoLabel
   where
-    p_lFieldLabelString (L s fs) = parensIfOp . atom @FastString $ fs
+    p_lFieldLabelString (L (locA -> s) fs) = parensIfOp . atom @FastString $ fs
       where
         -- HACK For OverloadedRecordUpdate:
         -- In operator field updates (i.e. `f {(+) = 1}`), we don't have
@@ -565,24 +566,27 @@ p_lhsFieldLabel = located' $ p_lFieldLabelString . hflLabel
               parens N
           | otherwise = id
 
-p_fieldLabels :: [Located (HsFieldLabel GhcPs)] -> R ()
-p_fieldLabels flss =
-  sep (txt ".") p_lhsFieldLabel flss
+p_ldotFieldOccs :: [XRec GhcPs (DotFieldOcc GhcPs)] -> R ()
+p_ldotFieldOccs = sep (txt ".") p_ldotFieldOcc
 
-p_hsRecField ::
-  (id -> R ()) ->
-  HsRecField' id (LHsExpr GhcPs) ->
+p_fieldOcc :: FieldOcc GhcPs -> R ()
+p_fieldOcc FieldOcc {..} = p_rdrName foLabel
+
+p_hsFieldBind ::
+  (lhs ~ GenLocated l a, HasSrcSpan l) =>
+  (lhs -> R ()) ->
+  HsFieldBind lhs (LHsExpr GhcPs) ->
   R ()
-p_hsRecField p_lbl HsRecField {..} = do
-  located hsRecFieldLbl p_lbl
-  unless hsRecPun $ do
+p_hsFieldBind p_lhs HsFieldBind {..} = do
+  p_lhs hfbLHS
+  unless hfbPun $ do
     space
     equals
     let placement =
-          if onTheSameLine (getLoc hsRecFieldLbl) (getLocA hsRecFieldArg)
-            then exprPlacement (unLoc hsRecFieldArg)
+          if onTheSameLine (getLoc' hfbLHS) (getLocA hfbRHS)
+            then exprPlacement (unLoc hfbRHS)
             else Normal
-    placeHanging placement (located hsRecFieldArg p_hsExpr)
+    placeHanging placement (located hfbRHS p_hsExpr)
 
 p_hsExpr :: HsExpr GhcPs -> R ()
 p_hsExpr = p_hsExpr' N
@@ -591,11 +595,7 @@ p_hsExpr' :: BracketStyle -> HsExpr GhcPs -> R ()
 p_hsExpr' s = \case
   HsVar _ name -> p_rdrName name
   HsUnboundVar _ occ -> atom occ
-  HsConLikeOut _ _ -> notImplemented "HsConLikeOut"
-  HsRecFld _ x ->
-    case x of
-      Unambiguous _ name -> p_rdrName name
-      Ambiguous _ name -> p_rdrName name
+  HsRecSel _ fldOcc -> p_fieldOcc fldOcc
   HsOverLabel _ v -> do
     txt "#"
     atom v
@@ -610,8 +610,8 @@ p_hsExpr' s = \case
       r -> atom r
   HsLam _ mgroup ->
     p_matchGroup Lambda mgroup
-  HsLamCase _ mgroup ->
-    p_lamcase exprPlacement p_hsExpr mgroup
+  HsLamCase _ variant mgroup ->
+    p_lamcase variant exprPlacement p_hsExpr mgroup
   HsApp _ f x -> do
     let -- In order to format function applications with multiple parameters
         -- nicer, traverse the AST to gather the function and all the
@@ -703,7 +703,7 @@ p_hsExpr' s = \case
     -- negated literals, as `- 1` and `-1` have differing AST.
     when (negativeLiterals && isLiteral) space
     located e p_hsExpr
-  HsPar _ e ->
+  HsPar _ _ e _ ->
     parens s $ sitcc (located e (dontUseBraces . p_hsExpr))
   SectionL _ x op -> do
     located x p_hsExpr
@@ -726,7 +726,9 @@ p_hsExpr' s = \case
           case boxity of
             Boxed -> parens
             Unboxed -> parensHash
-    enclSpan <- fmap (flip RealSrcSpan Nothing) . maybeToList <$> getEnclosingSpan (const True)
+    enclSpan <-
+      fmap (flip RealSrcSpan Strict.Nothing) . maybeToList
+        <$> getEnclosingSpan (const True)
     if isSection
       then
         switchLayout [] . parens' s $
@@ -744,9 +746,9 @@ p_hsExpr' s = \case
     txt "if"
     breakpoint
     inci . inci $ sep newline (located' (p_grhs RightArrow)) guards
-  HsLet _ localBinds e ->
-    p_let p_hsExpr localBinds e
-  HsDo _ ctx es -> do
+  HsLet _ epAnnLet localBinds _ e ->
+    p_let (s == S) p_hsExpr epAnnLet localBinds e
+  HsDo _ doFlavor es -> do
     let doBody moduleName header = do
           forM_ moduleName $ \m -> atom m *> txt "."
           txt header
@@ -769,16 +771,12 @@ p_hsExpr' s = \case
           txt "|"
           space
           p_parBody lists
-    case ctx of
+    case doFlavor of
       DoExpr moduleName -> doBody moduleName "do"
       MDoExpr moduleName -> doBody moduleName "mdo"
       ListComp -> compBody
       MonadComp -> compBody
-      ArrowExpr -> notImplemented "ArrowExpr"
       GhciStmtCtxt -> notImplemented "GhciStmtCtxt"
-      PatGuard _ -> notImplemented "PatGuard"
-      ParStmtCtxt _ -> notImplemented "ParStmtCtxt"
-      TransStmtCtxt _ -> notImplemented "TransStmtCtxt"
   ExplicitList _ xs ->
     brackets s $
       sep commaDel (sitcc . located' p_hsExprListItem) xs
@@ -786,8 +784,8 @@ p_hsExpr' s = \case
     located rcon_con atom
     breakpointPreRecordBrace
     let HsRecFields {..} = rcon_flds
-        p_lbl = p_rdrName . rdrNameFieldOcc
-        fields = located' (p_hsRecField p_lbl) <$> rec_flds
+        p_lhs = located' $ p_rdrName . foLabel
+        fields = located' (p_hsFieldBind p_lhs) <$> rec_flds
         dotdot =
           case rec_dotdot of
             Just {} -> [txt ".."]
@@ -798,23 +796,24 @@ p_hsExpr' s = \case
     located rupd_expr p_hsExpr
     breakpointPreRecordBrace
     let p_updLbl =
+          located' $
           p_rdrName . \case
-            Unambiguous NoExtField n -> n
+            (Unambiguous NoExtField n :: AmbiguousFieldOcc GhcPs) -> n
             Ambiguous NoExtField n -> n
         p_recFields p_lbl =
-          sep commaDel (sitcc . located' (p_hsRecField p_lbl))
+          sep commaDel (sitcc . located' (p_hsFieldBind p_lbl))
     inci . braces N $
       either
         (p_recFields p_updLbl)
-        (p_recFields (p_fieldLabels . coerce))
+        (p_recFields $ located' $ coerce p_ldotFieldOccs)
         rupd_flds
   HsGetField {..} -> do
     located gf_expr p_hsExpr
     txt "."
-    p_lhsFieldLabel gf_field
+    p_ldotFieldOcc gf_field
   HsProjection {..} -> parens N $ do
     txt "."
-    p_fieldLabels (NE.toList proj_flds)
+    p_ldotFieldOccs (NE.toList proj_flds)
   ExprWithTySig _ x HsWC {hswc_body} -> sitcc $ do
     located x p_hsExpr
     trailingArrowType
@@ -843,9 +842,13 @@ p_hsExpr' s = \case
         txt ".."
         space
         located to p_hsExpr
-  HsBracket epAnn x -> p_hsBracket epAnn x
-  HsRnBracketOut {} -> notImplemented "HsRnBracketOut"
-  HsTcBracketOut {} -> notImplemented "HsTcBracketOut"
+  HsTypedBracket _ expr -> do
+    txt "[||"
+    breakpoint'
+    located expr p_hsExpr
+    breakpoint'
+    txt "||]"
+  HsUntypedBracket epAnn x -> p_hsQuote epAnn x
   HsSpliceE _ splice -> p_hsSplice splice
   HsProc _ p e -> do
     txt "proc"
@@ -860,8 +863,6 @@ p_hsExpr' s = \case
     txt "static"
     breakpoint
     inci (located e p_hsExpr)
-  HsTick {} -> notImplemented "HsTick"
-  HsBinTick {} -> notImplemented "HsBinTick"
   HsPragE _ prag x -> case prag of
     HsPragSCC _ _ name -> do
       txt "{-# SCC "
@@ -930,7 +931,7 @@ p_patSynBind PSB {..} = do
       inci (rhs conSpans)
 
 p_case ::
-  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcSpan,
+  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcAnn NoEpAnns,
     Anno (Match GhcPs (LocatedA body)) ~ SrcSpanAnnA
   ) =>
   -- | Placer
@@ -952,9 +953,11 @@ p_case placer render e mgroup = do
   inci (p_matchGroup' placer render Case mgroup)
 
 p_lamcase ::
-  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcSpan,
+  ( Anno (GRHS GhcPs (LocatedA body)) ~ SrcAnn NoEpAnns,
     Anno (Match GhcPs (LocatedA body)) ~ SrcSpanAnnA
   ) =>
+  -- | Variant (@\\case@ or @\\cases@)
+  LamCaseVariant ->
   -- | Placer
   (body -> Placement) ->
   -- | Render
@@ -962,8 +965,10 @@ p_lamcase ::
   -- | Expression
   MatchGroup GhcPs (LocatedA body) ->
   R ()
-p_lamcase placer render mgroup = do
-  txt "\\case"
+p_lamcase variant placer render mgroup = do
+  txt $ case variant of
+    LamCase -> "\\case"
+    LamCases -> "\\cases"
   breakpoint
   inci (p_matchGroup' placer render LambdaCase mgroup)
 
@@ -996,19 +1001,98 @@ p_if placer render if' then' else' = do
       placeHanging (placer x) (render x)
 
 p_let ::
+  -- | True if in do-block
+  Bool ->
   -- | Render
   (body -> R ()) ->
+  -- | Annotation for the `let` block
+  GenLocated TokenLocation (HsToken a) ->
   HsLocalBinds GhcPs ->
   LocatedA body ->
   R ()
-p_let render localBinds e = sitcc $ do
-  txt "let"
-  space
-  dontUseBraces $ sitcc (p_hsLocalBinds localBinds)
-  vlayout space (newline >> txt " ")
-  txt "in"
-  space
-  sitcc (located e render)
+p_let inDo render epAnnLet localBinds e = p_let' inDo letLoc localBinds $ Just (located e render)
+  where
+    letLoc =
+      let L loc _tok = epAnnLet
+       in case loc of
+            TokenLoc innerLoc -> Just innerLoc
+            NoTokenLoc -> Nothing
+
+p_let' ::
+  -- | True if in do-block
+  Bool ->
+  -- | Annotation for the `let` block
+  Maybe EpaLocation ->
+  -- | Let bindings
+  HsLocalBinds GhcPs ->
+  -- | Optional 'in' body
+  Maybe (R ()) ->
+  R ()
+p_let' inDo letLoc localBinds mBody = do
+  letStyle <- getPrinterOpt poLetStyle
+  inStyle <- getPrinterOpt poInStyle
+  layout <- getLayout
+  -- isAllInline = True if whole "let ... in ..." is one line
+  let isAllInline = not inDo && layout == SingleLine
+  -- isBlockInline = True if each "let ..." + "in ..." block is one line
+  let isBlockInline =
+        case letStyle of
+          _ | isAllInline -> True
+          LetAuto ->
+            -- check if local binds are on the same line as the "let" keyword;
+            -- if we can't figure out the positions, just fallback to `inline` style
+            fromMaybe True $ do
+              letStartLine <- srcSpanStartLine . epaLocationRealSrcSpan <$> letLoc
+              localBindsStartLine <- localBindsEpAnns localBinds >>= epAnnsStartLine
+              pure $
+                -- special case when let has zero local binds
+                if localBindsStartLine == -1
+                  then True
+                  else letStartLine == localBindsStartLine
+          LetInline -> True
+          LetNewline -> False
+          LetMixed -> numLocalBinds <= 1
+  -- isInShifted = True if "in" is right-aligned with "let"
+  let isInShifted = inDo || inStyle == InRightAlign
+
+  -- helpers
+  let block keyword body = do
+        txt keyword
+        if isBlockInline
+          then space >> sitcc body
+          else newline >> inci body
+
+  sitcc $ do
+    block "let" (p_hsLocalBinds localBinds)
+
+    case mBody of
+      Just body
+        | isAllInline -> do
+            space
+            block "in" body
+        | otherwise -> do
+            newline
+            let in_
+                  | isInShifted = " in"
+                  | isBlockInline = "in "
+                  | otherwise = "in"
+            block in_ body
+      Nothing -> pure ()
+  where
+    numLocalBinds =
+      case localBinds of
+        HsValBinds _ (ValBinds _ binds sigs) -> length binds + length sigs
+        HsValBinds _ (XValBindsLR (NValBinds binds sigs)) -> length binds + length sigs
+        HsIPBinds _ (IPBinds _ binds) -> length binds
+        EmptyLocalBinds _ -> 0
+
+    localBindsEpAnns = \case
+      HsValBinds epanns _ -> Just epanns
+      HsIPBinds epanns _ -> Just epanns
+      EmptyLocalBinds _ -> Nothing
+    epAnnsStartLine = \case
+      EpAnn {entry} -> Just (srcSpanStartLine . anchor $ entry)
+      EpAnnNotUsed -> Nothing
 
 p_pat :: Pat GhcPs -> R ()
 p_pat = \case
@@ -1021,7 +1105,7 @@ p_pat = \case
     p_rdrName name
     txt "@"
     located pat p_pat
-  ParPat _ pat ->
+  ParPat _ _ pat _ ->
     located pat (parens S . sitcc . p_pat)
   BangPat _ pat -> do
     txt "!"
@@ -1050,7 +1134,7 @@ p_pat = \case
         breakpointPreRecordBrace
         let f = \case
               Nothing -> txt ".."
-              Just x -> located x p_pat_hsRecField
+              Just x -> located x p_pat_hsFieldBind
         inci . braces N . sep commaDel f $
           case dotdot of
             Nothing -> Just <$> fields
@@ -1088,14 +1172,14 @@ p_pat = \case
     located pat p_pat
     p_typeAscription (lhsTypeToSigType hsps_body)
 
-p_pat_hsRecField :: HsRecField' (FieldOcc GhcPs) (LPat GhcPs) -> R ()
-p_pat_hsRecField HsRecField {..} = do
-  located hsRecFieldLbl $ p_rdrName . rdrNameFieldOcc
-  unless hsRecPun $ do
+p_pat_hsFieldBind :: HsRecField GhcPs (LPat GhcPs) -> R ()
+p_pat_hsFieldBind HsFieldBind {..} = do
+  located hfbLHS p_fieldOcc
+  unless hfbPun $ do
     space
     equals
     breakpoint
-    inci (located hsRecFieldArg p_pat)
+    inci (located hfbRHS p_pat)
 
 p_unboxedSum :: BracketStyle -> ConTag -> Arity -> R () -> R ()
 p_unboxedSum s tag arity m = do
@@ -1143,8 +1227,8 @@ p_hsSpliceTH isTyped expr = \case
   where
     decoSymbol = if isTyped then "$$" else "$"
 
-p_hsBracket :: EpAnn [AddEpAnn] -> HsBracket GhcPs -> R ()
-p_hsBracket epAnn = \case
+p_hsQuote :: EpAnn [AddEpAnn] -> HsQuote GhcPs -> R ()
+p_hsQuote epAnn = \case
   ExpBr _ expr -> do
     let name
           | or [True | AddEpAnn AnnOpenEQ _ <- epAnnAnns epAnn] = ""
@@ -1157,12 +1241,6 @@ p_hsBracket epAnn = \case
   VarBr _ isSingleQuote name -> do
     txt (bool "''" "'" isSingleQuote)
     p_rdrName name
-  TExpBr _ expr -> do
-    txt "[||"
-    breakpoint'
-    located expr p_hsExpr
-    breakpoint'
-    txt "||]"
   where
     quote :: Text -> R () -> R ()
     quote name body = do
@@ -1268,7 +1346,7 @@ cmdPlacement :: HsCmd GhcPs -> Placement
 cmdPlacement = \case
   HsCmdLam _ _ -> Hanging
   HsCmdCase _ _ _ -> Hanging
-  HsCmdLamCase _ _ -> Hanging
+  HsCmdLamCase _ _ _ -> Hanging
   HsCmdDo _ _ -> Hanging
   _ -> Normal
 
@@ -1285,7 +1363,7 @@ exprPlacement = \case
       | isOneLineSpan (combineSrcSpans' $ fmap getLocA (x :| xs)) ->
           Hanging
     _ -> Normal
-  HsLamCase _ _ -> Hanging
+  HsLamCase _ _ _ -> Hanging
   HsCase _ _ _ -> Hanging
   HsDo _ (DoExpr _) _ -> Hanging
   HsDo _ (MDoExpr _) _ -> Hanging
diff --git a/src/Ormolu/Printer/Meat/Declaration/Warning.hs b/src/Ormolu/Printer/Meat/Declaration/Warning.hs
index f07e0e7..583fd93 100644
--- a/src/Ormolu/Printer/Meat/Declaration/Warning.hs
+++ b/src/Ormolu/Printer/Meat/Declaration/Warning.hs
@@ -25,12 +25,12 @@ p_warnDecl :: WarnDecl GhcPs -> R ()
 p_warnDecl (Warning _ functions warningTxt) =
   p_topLevelWarning functions warningTxt
 
-p_moduleWarning :: WarningTxt -> R ()
+p_moduleWarning :: WarningTxt GhcPs -> R ()
 p_moduleWarning wtxt = do
   let (pragmaText, lits) = warningText wtxt
   inci $ pragma pragmaText $ inci $ p_lits lits
 
-p_topLevelWarning :: [LocatedN RdrName] -> WarningTxt -> R ()
+p_topLevelWarning :: [LocatedN RdrName] -> WarningTxt GhcPs -> R ()
 p_topLevelWarning fnames wtxt = do
   let (pragmaText, lits) = warningText wtxt
   switchLayout (fmap getLocA fnames ++ fmap getLoc lits) $
@@ -39,10 +39,10 @@ p_topLevelWarning fnames wtxt = do
       breakpoint
       p_lits lits
 
-warningText :: WarningTxt -> (Text, [Located StringLiteral])
+warningText :: WarningTxt GhcPs -> (Text, [Located StringLiteral])
 warningText = \case
-  WarningTxt _ lits -> ("WARNING", lits)
-  DeprecatedTxt _ lits -> ("DEPRECATED", lits)
+  WarningTxt _ lits -> ("WARNING", fmap hsDocString <$> lits)
+  DeprecatedTxt _ lits -> ("DEPRECATED", fmap hsDocString <$> lits)
 
 p_lits :: [Located StringLiteral] -> R ()
 p_lits = \case
diff --git a/src/Ormolu/Printer/Meat/ImportExport.hs b/src/Ormolu/Printer/Meat/ImportExport.hs
index a29ddf7..52b485f 100644
--- a/src/Ormolu/Printer/Meat/ImportExport.hs
+++ b/src/Ormolu/Printer/Meat/ImportExport.hs
@@ -14,6 +14,7 @@ import Control.Monad
 import qualified Data.Text as T
 import GHC.Hs
 import GHC.LanguageExtensions.Type
+import GHC.Types.PkgQual
 import GHC.Types.SrcLoc
 import GHC.Unit.Types
 import Ormolu.Config
@@ -48,8 +49,8 @@ p_hsmodImport ImportDecl {..} = do
     (txt "qualified")
   space
   case ideclPkgQual of
-    Nothing -> return ()
-    Just slit -> atom slit
+    NoRawPkgQual -> return ()
+    RawPkgQual slit -> atom slit
   space
   inci $ do
     located ideclName atom
@@ -113,10 +114,10 @@ p_lie encLayout relativePos = \case
       MiddlePos -> newline
       LastPos -> newline
       FirstAfterDocPos -> newline
-    indentDoc $ p_hsDocString (Asterisk n) False (noLoc str)
+    indentDoc $ p_hsDoc (Asterisk n) False str
   IEDoc NoExtField str ->
     indentDoc $
-      p_hsDocString Pipe False (noLoc str)
+      p_hsDoc Pipe False str
   IEDocNamed NoExtField str -> indentDoc $ txt $ "-- $" <> T.pack str
   where
     -- Add a comma to a import-export list element
diff --git a/src/Ormolu/Printer/Meat/Module.hs b/src/Ormolu/Printer/Meat/Module.hs
index 30c8b0e..00422c0 100644
--- a/src/Ormolu/Printer/Meat/Module.hs
+++ b/src/Ormolu/Printer/Meat/Module.hs
@@ -47,7 +47,7 @@ p_hsModule mstackHeader pragmas HsModule {..} = do
       Nothing -> return ()
       Just hsmodName' -> do
         located hsmodName' $ \name -> do
-          forM_ hsmodHaddockModHeader (p_hsDocString Pipe True)
+          forM_ hsmodHaddockModHeader (p_hsDoc Pipe True)
           p_hsmodName name
         forM_ hsmodDeprecMessage $ \w -> do
           breakpoint
diff --git a/src/Ormolu/Printer/Meat/Type.hs b/src/Ormolu/Printer/Meat/Type.hs
index 75e0b17..675202d 100644
--- a/src/Ormolu/Printer/Meat/Type.hs
+++ b/src/Ormolu/Printer/Meat/Type.hs
@@ -24,7 +24,6 @@ where
 
 import Control.Monad
 import Data.Bool (bool)
-import Data.Foldable (for_)
 import GHC.Hs
 import GHC.Types.Basic hiding (isPromoted)
 import GHC.Types.SourceText
@@ -79,19 +78,18 @@ p_hsType' multilineArgs docStyle = \case
       _ -> p_after False >> setPrevTypeCtx TypeCtxStart
     interArgBreak
     p_hsTypeR (unLoc t)
-  HsQualTy _ qs' t -> do
+  HsQualTy _ qs t -> do
     getPrinterOpt poFunctionArrows >>= \case
       LeadingArrows -> do
         after <- getPrevTypeCtx
-        bool id (inciByExact 3) (after == TypeCtxForall) $ for_ qs' $ \qs -> do
+        bool id (inciByExact 3) (after == TypeCtxForall) $ do
           located qs p_hsContext
           interArgBreak
       TrailingArrows -> do
-        for_ qs' $ \qs -> do
-          located qs p_hsContext
-          space
-          txt "=>"
-          interArgBreak
+        located qs p_hsContext
+        space
+        txt "=>"
+        interArgBreak
     setPrevTypeCtx TypeCtxContext
     case unLoc t of
       HsQualTy {} -> p_hsTypeR (unLoc t)
@@ -141,8 +139,8 @@ p_hsType' multilineArgs docStyle = \case
         space
         case arrow of
           HsUnrestrictedArrow _ -> txt "->"
-          HsLinearArrow _ _ -> txt "%1 ->"
-          HsExplicitMult _ _ mult -> do
+          HsLinearArrow _ -> txt "%1 ->"
+          HsExplicitMult _ mult _ -> do
             txt "%"
             setPrevTypeCtx TypeCtxContext
             p_hsTypeR (unLoc mult)
@@ -167,7 +165,7 @@ p_hsType' multilineArgs docStyle = \case
   HsSumTy _ xs ->
     parensHash N $
       sep (space >> txt "|" >> breakpoint) (sitcc . located' p_hsType) xs
-  HsOpTy _ x op y -> do
+  HsOpTy _ _ x op y -> do
     fixityOverrides <- askFixityOverrides
     fixityMap <- askFixityMap
     let opTree = OpBranches [tyOpTree x, tyOpTree y] [op]
@@ -192,12 +190,12 @@ p_hsType' multilineArgs docStyle = \case
   HsDocTy _ t str ->
     case docStyle of
       PipeStyle -> do
-        p_hsDocString Pipe True str
+        p_hsDoc Pipe True str
         located t p_hsType
       CaretStyle -> do
         located t p_hsType
         newline
-        p_hsDocString Caret False str
+        p_hsDoc Caret False str
   HsBangTy _ (HsSrcBang _ u s) t -> do
     case u of
       SrcUnpack -> txt "{-# UNPACK #-}" >> space
@@ -292,16 +290,16 @@ p_hsTyVarBndr = \case
 data ForAllVisibility = ForAllInvis | ForAllVis
 
 -- | Render several @forall@-ed variables.
-p_forallBndrs :: ForAllVisibility -> (a -> R ()) -> [LocatedA a] -> R ()
+p_forallBndrs :: HasSrcSpan l => ForAllVisibility -> (a -> R ()) -> [GenLocated l a] -> R ()
 p_forallBndrs vis p tyvars = do
   p_forallBndrs' vis p tyvars
   p_after False
 
-p_forallBndrs' :: ForAllVisibility -> (a -> R ()) -> [LocatedA a] -> R ()
+p_forallBndrs' :: HasSrcSpan l => ForAllVisibility -> (a -> R ()) -> [GenLocated l a] -> R ()
 p_forallBndrs' ForAllInvis _ [] = txt "forall" >> setPrevTypeCtx TypeCtxForall
 p_forallBndrs' ForAllVis _ [] = txt "forall" >> space >> setPrevTypeCtx TypeCtxArgument
 p_forallBndrs' vis p tyvars = do
-  switchLayout (getLocA <$> tyvars) $ do
+  switchLayout (getLoc' <$> tyvars) $ do
     txt "forall"
     breakpoint
     inci $ do
@@ -318,11 +316,11 @@ p_conDeclField :: ConDeclField GhcPs -> R ()
 p_conDeclField ConDeclField {..} = do
   commaStyle <- getPrinterOpt poCommaStyle
   when (commaStyle == Trailing) $
-    mapM_ (p_hsDocString Pipe True) cd_fld_doc
+    mapM_ (p_hsDoc Pipe True) cd_fld_doc
   sitcc $
     sep
       commaDel
-      (located' (p_rdrName . rdrNameFieldOcc))
+      (located' (p_rdrName . foLabel))
       cd_fld_names
   getPrinterOpt poFunctionArrows >>= \case
     LeadingArrows -> inci $ do
@@ -336,7 +334,7 @@ p_conDeclField ConDeclField {..} = do
       breakpoint
       sitcc . inci $ p_hsType (unLoc cd_fld_type)
   when (commaStyle == Leading) $
-    mapM_ (inciByFrac (-1) . (newline >>) . p_hsDocString Caret False) cd_fld_doc
+    mapM_ (inciByFrac (-1) . (newline >>) . p_hsDoc Caret False) cd_fld_doc
 
 p_lhsTypeArg :: LHsTypeArg GhcPs -> R ()
 p_lhsTypeArg = \case
diff --git a/src/Ormolu/Utils.hs b/src/Ormolu/Utils.hs
index a6bb1e0..22d589f 100644
--- a/src/Ormolu/Utils.hs
+++ b/src/Ormolu/Utils.hs
@@ -26,6 +26,7 @@ import qualified Data.List.NonEmpty as NE
 import Data.Maybe (fromMaybe)
 import Data.Text (Text)
 import qualified Data.Text as T
+import qualified GHC.Data.Strict as Strict
 import GHC.Driver.Ppr
 import GHC.DynFlags (baseDynFlags)
 import GHC.Hs
@@ -77,7 +78,7 @@ splitDocString docStr =
         . dropWhileEnd T.null
         . fmap (T.stripEnd . T.pack)
         . lines
-        $ unpackHDS docStr
+        $ renderHsDocString docStr
     -- We cannot have the first character to be a dollar because in that
     -- case it'll be a parse error (apparently collides with named docs
     -- syntax @-- $name@ somehow).
@@ -98,7 +99,7 @@ incSpanLine i = \case
               line = srcLocLine x
               col = srcLocCol x
            in mkRealSrcLoc file (line + i) col
-     in RealSrcSpan (mkRealSrcSpan (incLine start) (incLine end)) Nothing
+     in RealSrcSpan (mkRealSrcSpan (incLine start) (incLine end)) Strict.Nothing
   UnhelpfulSpan x -> UnhelpfulSpan x
 
 -- | Do two declarations have a blank between them?
diff --git a/tests/Ormolu/CabalInfoSpec.hs b/tests/Ormolu/CabalInfoSpec.hs
index 95e8d35..60fe02c 100644
--- a/tests/Ormolu/CabalInfoSpec.hs
+++ b/tests/Ormolu/CabalInfoSpec.hs
@@ -38,7 +38,7 @@ spec = do
       ciDynOpts `shouldBe` [DynOption "-XHaskell2010"]
     it "extracts correct dependencies from fourmolu.cabal (src/Ormolu/Config.hs)" $ do
       CabalInfo {..} <- parseCabalInfo "fourmolu.cabal" "src/Ormolu/Config.hs"
-      ciDependencies `shouldBe` Set.fromList ["Cabal", "Diff", "MemoTrie", "aeson", "ansi-terminal", "array", "base", "bytestring", "containers", "directory", "dlist", "exceptions", "file-embed", "filepath", "ghc-lib-parser", "megaparsec", "mtl", "syb", "template-haskell", "text", "th-lift-instances", "yaml"]
+      ciDependencies `shouldBe` Set.fromList ["Cabal-syntax", "Diff", "MemoTrie", "aeson", "ansi-terminal", "array", "base", "bytestring", "containers", "directory", "dlist", "exceptions", "file-embed", "filepath", "ghc-lib-parser", "megaparsec", "mtl", "syb", "template-haskell", "text", "th-lift-instances", "yaml"]
     it "extracts correct dependencies from fourmolu.cabal (tests/Ormolu/PrinterSpec.hs)" $ do
       CabalInfo {..} <- parseCabalInfo "fourmolu.cabal" "tests/Ormolu/PrinterSpec.hs"
       ciDependencies `shouldBe` Set.fromList ["Diff", "QuickCheck", "base", "containers", "directory", "filepath", "ghc-lib-parser", "hspec", "hspec-megaparsec", "megaparsec", "fourmolu", "path", "path-io", "pretty", "process", "temporary", "text"]
diff --git a/tests/Ormolu/Config/PrinterOptsSpec.hs b/tests/Ormolu/Config/PrinterOptsSpec.hs
index d8dbba4..d549ec5 100644
--- a/tests/Ormolu/Config/PrinterOptsSpec.hs
+++ b/tests/Ormolu/Config/PrinterOptsSpec.hs
@@ -1,4 +1,5 @@
 {-# LANGUAGE GADTs #-}
+{-# LANGUAGE LambdaCase #-}
 {-# LANGUAGE QuasiQuotes #-}
 {-# LANGUAGE RecordWildCards #-}
 
@@ -9,11 +10,13 @@
 -- testing.
 module Ormolu.Config.PrinterOptsSpec (spec) where
 
+import Control.Exception (catch)
 import Control.Monad (forM_, when)
 import Data.Algorithm.DiffContext (getContextDiff, prettyContextDiff)
 import Data.Maybe (isJust)
 import Data.Text (Text)
 import qualified Data.Text as T
+import GHC.Stack (withFrozenCallStack)
 import Ormolu
   ( Config (..),
     PrinterOpts (..),
@@ -23,6 +26,8 @@ import Ormolu
     detectSourceType,
     ormolu,
   )
+import Ormolu.Exception (OrmoluException, printOrmoluException)
+import Ormolu.Terminal (ColorMode (..), runTerm)
 import Ormolu.Utils.IO (readFileUtf8, writeFileUtf8)
 import Path
   ( File,
@@ -35,9 +40,12 @@ import Path
   )
 import Path.IO (doesFileExist)
 import System.Environment (lookupEnv)
+import System.IO (hClose)
+import System.IO.Temp (withSystemTempFile)
 import System.IO.Unsafe (unsafePerformIO)
 import Test.Hspec
 import qualified Text.PrettyPrint as Doc
+import Text.Printf (printf)
 
 data TestGroup = forall a.
   TestGroup
@@ -88,6 +96,20 @@ spec =
           showTestCase = show,
           testCaseSuffix = suffix1
         },
+      TestGroup
+        { label = "let-style",
+          testCases = (,,) <$> allOptions <*> allOptions <*> [2, 4],
+          updateConfig = \(letStyle, inStyle, indent) opts ->
+            opts
+              { poIndentation = pure indent,
+                poLetStyle = pure letStyle,
+                poInStyle = pure inStyle
+              },
+          showTestCase = \(letStyle, inStyle, indent) ->
+            printf "%s + %s (indent=%d)" (show letStyle) (show inStyle) indent,
+          testCaseSuffix = \(letStyle, inStyle, indent) ->
+            suffixWith [show letStyle, show inStyle, "indent=" ++ show indent]
+        },
       TestGroup
         { label = "record-brace-space",
           testCases = allOptions,
@@ -145,20 +167,20 @@ runTestGroup TestGroup {..} =
                   cfgSourceType = detectSourceType inputPath,
                   cfgCheckIdempotence = True
                 }
-            runOrmolu path = ormolu config path . T.unpack
 
         input <- readFileUtf8 inputPath
-        actual <- runOrmolu inputPath input
-        mExpected <- getFileContents outputFile
-        case (shouldRegenerateOutput, mExpected) of
-          (False, Nothing) ->
+        actual <-
+          ormolu config inputPath (T.unpack input) `catch` \e -> do
+            msg <- renderOrmoluException e
+            expectationFailure' $ unlines ["Got ormolu exception:", "", msg]
+        getFileContents outputFile >>= \case
+          _ | shouldRegenerateOutput -> writeFileUtf8 outputPath actual
+          Nothing ->
             expectationFailure "Output does not exist. Try running with ORMOLU_REGENERATE_EXAMPLES=1"
-          (False, Just expected) ->
+          Just expected ->
             when (actual /= expected) $
               expectationFailure . T.unpack $
                 getDiff ("actual", actual) ("expected", expected)
-          (True, _) ->
-            writeFileUtf8 outputPath actual
   where
     testDir = toRelDir $ "data/fourmolu/" ++ label
     toRelDir name =
@@ -185,6 +207,19 @@ getDiff (s1Name, s1) (s2Name, s2) =
     prettyContextDiff (Doc.text s1Name) (Doc.text s2Name) (Doc.text . T.unpack) $
       getContextDiff 2 (T.lines s1) (T.lines s2)
 
+renderOrmoluException :: OrmoluException -> IO String
+renderOrmoluException e =
+  withSystemTempFile "PrinterOptsSpec" $ \fp handle -> do
+    runTerm (printOrmoluException e) Never handle
+    hClose handle
+    readFile fp
+
+expectationFailure' :: HasCallStack => String -> IO a
+expectationFailure' msg = do
+  withFrozenCallStack $ expectationFailure msg
+  -- satisfy type-checker, since hspec's expectationFailure is IO ()
+  error "unreachable"
+
 shouldRegenerateOutput :: Bool
 shouldRegenerateOutput =
   -- Use same env var as PrinterSpec.hs, to make it easy to regenerate everything at once
